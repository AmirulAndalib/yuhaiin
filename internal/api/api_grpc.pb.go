// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
	context "context"

	config "github.com/Asutorufa/yuhaiin/internal/config"
	empty "github.com/golang/protobuf/ptypes/empty"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ProcessInitClient is the client API for ProcessInit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProcessInitClient interface {
	CreateLockFile(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	ProcessInit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	GetRunningHost(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.StringValue, error)
	ClientOn(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	ProcessExit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	GetKernelPid(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.UInt32Value, error)
	StopKernel(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	SingleInstance(ctx context.Context, opts ...grpc.CallOption) (ProcessInit_SingleInstanceClient, error)
}

type processInitClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessInitClient(cc grpc.ClientConnInterface) ProcessInitClient {
	return &processInitClient{cc}
}

func (c *processInitClient) CreateLockFile(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/CreateLockFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) ProcessInit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/ProcessInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) GetRunningHost(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.StringValue, error) {
	out := new(wrappers.StringValue)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/GetRunningHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) ClientOn(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/ClientOn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) ProcessExit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/ProcessExit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) GetKernelPid(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.UInt32Value, error) {
	out := new(wrappers.UInt32Value)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/GetKernelPid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) StopKernel(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.processInit/StopKernel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processInitClient) SingleInstance(ctx context.Context, opts ...grpc.CallOption) (ProcessInit_SingleInstanceClient, error) {
	stream, err := c.cc.NewStream(ctx, &ProcessInit_ServiceDesc.Streams[0], "/yuhaiin.api.processInit/SingleInstance", opts...)
	if err != nil {
		return nil, err
	}
	x := &processInitSingleInstanceClient{stream}
	return x, nil
}

type ProcessInit_SingleInstanceClient interface {
	Send(*wrappers.StringValue) error
	Recv() (*wrappers.StringValue, error)
	grpc.ClientStream
}

type processInitSingleInstanceClient struct {
	grpc.ClientStream
}

func (x *processInitSingleInstanceClient) Send(m *wrappers.StringValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *processInitSingleInstanceClient) Recv() (*wrappers.StringValue, error) {
	m := new(wrappers.StringValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ProcessInitServer is the server API for ProcessInit service.
// All implementations must embed UnimplementedProcessInitServer
// for forward compatibility
type ProcessInitServer interface {
	CreateLockFile(context.Context, *empty.Empty) (*empty.Empty, error)
	ProcessInit(context.Context, *empty.Empty) (*empty.Empty, error)
	GetRunningHost(context.Context, *empty.Empty) (*wrappers.StringValue, error)
	ClientOn(context.Context, *empty.Empty) (*empty.Empty, error)
	ProcessExit(context.Context, *empty.Empty) (*empty.Empty, error)
	GetKernelPid(context.Context, *empty.Empty) (*wrappers.UInt32Value, error)
	StopKernel(context.Context, *empty.Empty) (*empty.Empty, error)
	SingleInstance(ProcessInit_SingleInstanceServer) error
	mustEmbedUnimplementedProcessInitServer()
}

// UnimplementedProcessInitServer must be embedded to have forward compatible implementations.
type UnimplementedProcessInitServer struct {
}

func (UnimplementedProcessInitServer) CreateLockFile(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLockFile not implemented")
}
func (UnimplementedProcessInitServer) ProcessInit(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessInit not implemented")
}
func (UnimplementedProcessInitServer) GetRunningHost(context.Context, *empty.Empty) (*wrappers.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRunningHost not implemented")
}
func (UnimplementedProcessInitServer) ClientOn(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientOn not implemented")
}
func (UnimplementedProcessInitServer) ProcessExit(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessExit not implemented")
}
func (UnimplementedProcessInitServer) GetKernelPid(context.Context, *empty.Empty) (*wrappers.UInt32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKernelPid not implemented")
}
func (UnimplementedProcessInitServer) StopKernel(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopKernel not implemented")
}
func (UnimplementedProcessInitServer) SingleInstance(ProcessInit_SingleInstanceServer) error {
	return status.Errorf(codes.Unimplemented, "method SingleInstance not implemented")
}
func (UnimplementedProcessInitServer) mustEmbedUnimplementedProcessInitServer() {}

// UnsafeProcessInitServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessInitServer will
// result in compilation errors.
type UnsafeProcessInitServer interface {
	mustEmbedUnimplementedProcessInitServer()
}

func RegisterProcessInitServer(s grpc.ServiceRegistrar, srv ProcessInitServer) {
	s.RegisterService(&ProcessInit_ServiceDesc, srv)
}

func _ProcessInit_CreateLockFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).CreateLockFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/CreateLockFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).CreateLockFile(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_ProcessInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).ProcessInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/ProcessInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).ProcessInit(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_GetRunningHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).GetRunningHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/GetRunningHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).GetRunningHost(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_ClientOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).ClientOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/ClientOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).ClientOn(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_ProcessExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).ProcessExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/ProcessExit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).ProcessExit(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_GetKernelPid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).GetKernelPid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/GetKernelPid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).GetKernelPid(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_StopKernel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessInitServer).StopKernel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.processInit/StopKernel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessInitServer).StopKernel(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessInit_SingleInstance_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ProcessInitServer).SingleInstance(&processInitSingleInstanceServer{stream})
}

type ProcessInit_SingleInstanceServer interface {
	Send(*wrappers.StringValue) error
	Recv() (*wrappers.StringValue, error)
	grpc.ServerStream
}

type processInitSingleInstanceServer struct {
	grpc.ServerStream
}

func (x *processInitSingleInstanceServer) Send(m *wrappers.StringValue) error {
	return x.ServerStream.SendMsg(m)
}

func (x *processInitSingleInstanceServer) Recv() (*wrappers.StringValue, error) {
	m := new(wrappers.StringValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ProcessInit_ServiceDesc is the grpc.ServiceDesc for ProcessInit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProcessInit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.processInit",
	HandlerType: (*ProcessInitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLockFile",
			Handler:    _ProcessInit_CreateLockFile_Handler,
		},
		{
			MethodName: "ProcessInit",
			Handler:    _ProcessInit_ProcessInit_Handler,
		},
		{
			MethodName: "GetRunningHost",
			Handler:    _ProcessInit_GetRunningHost_Handler,
		},
		{
			MethodName: "ClientOn",
			Handler:    _ProcessInit_ClientOn_Handler,
		},
		{
			MethodName: "ProcessExit",
			Handler:    _ProcessInit_ProcessExit_Handler,
		},
		{
			MethodName: "GetKernelPid",
			Handler:    _ProcessInit_GetKernelPid_Handler,
		},
		{
			MethodName: "StopKernel",
			Handler:    _ProcessInit_StopKernel_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SingleInstance",
			Handler:       _ProcessInit_SingleInstance_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api/api.proto",
}

// ConfigClient is the client API for Config service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigClient interface {
	GetConfig(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*config.Setting, error)
	SetConfig(ctx context.Context, in *config.Setting, opts ...grpc.CallOption) (*empty.Empty, error)
	ReimportRule(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	GetRate(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (Config_GetRateClient, error)
}

type configClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigClient(cc grpc.ClientConnInterface) ConfigClient {
	return &configClient{cc}
}

func (c *configClient) GetConfig(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*config.Setting, error) {
	out := new(config.Setting)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.config/GetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configClient) SetConfig(ctx context.Context, in *config.Setting, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.config/SetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configClient) ReimportRule(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.config/ReimportRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configClient) GetRate(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (Config_GetRateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Config_ServiceDesc.Streams[0], "/yuhaiin.api.config/getRate", opts...)
	if err != nil {
		return nil, err
	}
	x := &configGetRateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Config_GetRateClient interface {
	Recv() (*DaUaDrUr, error)
	grpc.ClientStream
}

type configGetRateClient struct {
	grpc.ClientStream
}

func (x *configGetRateClient) Recv() (*DaUaDrUr, error) {
	m := new(DaUaDrUr)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConfigServer is the server API for Config service.
// All implementations must embed UnimplementedConfigServer
// for forward compatibility
type ConfigServer interface {
	GetConfig(context.Context, *empty.Empty) (*config.Setting, error)
	SetConfig(context.Context, *config.Setting) (*empty.Empty, error)
	ReimportRule(context.Context, *empty.Empty) (*empty.Empty, error)
	GetRate(*empty.Empty, Config_GetRateServer) error
	mustEmbedUnimplementedConfigServer()
}

// UnimplementedConfigServer must be embedded to have forward compatible implementations.
type UnimplementedConfigServer struct {
}

func (UnimplementedConfigServer) GetConfig(context.Context, *empty.Empty) (*config.Setting, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedConfigServer) SetConfig(context.Context, *config.Setting) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetConfig not implemented")
}
func (UnimplementedConfigServer) ReimportRule(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReimportRule not implemented")
}
func (UnimplementedConfigServer) GetRate(*empty.Empty, Config_GetRateServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRate not implemented")
}
func (UnimplementedConfigServer) mustEmbedUnimplementedConfigServer() {}

// UnsafeConfigServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigServer will
// result in compilation errors.
type UnsafeConfigServer interface {
	mustEmbedUnimplementedConfigServer()
}

func RegisterConfigServer(s grpc.ServiceRegistrar, srv ConfigServer) {
	s.RegisterService(&Config_ServiceDesc, srv)
}

func _Config_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.config/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServer).GetConfig(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Config_SetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.Setting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServer).SetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.config/SetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServer).SetConfig(ctx, req.(*config.Setting))
	}
	return interceptor(ctx, in, info, handler)
}

func _Config_ReimportRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServer).ReimportRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.config/ReimportRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServer).ReimportRule(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Config_GetRate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConfigServer).GetRate(m, &configGetRateServer{stream})
}

type Config_GetRateServer interface {
	Send(*DaUaDrUr) error
	grpc.ServerStream
}

type configGetRateServer struct {
	grpc.ServerStream
}

func (x *configGetRateServer) Send(m *DaUaDrUr) error {
	return x.ServerStream.SendMsg(m)
}

// Config_ServiceDesc is the grpc.ServiceDesc for Config service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Config_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.config",
	HandlerType: (*ConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfig",
			Handler:    _Config_GetConfig_Handler,
		},
		{
			MethodName: "SetConfig",
			Handler:    _Config_SetConfig_Handler,
		},
		{
			MethodName: "ReimportRule",
			Handler:    _Config_ReimportRule_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getRate",
			Handler:       _Config_GetRate_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/api.proto",
}

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeClient interface {
	GetNodes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Nodes, error)
	GetGroup(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AllGroupOrNode, error)
	GetNode(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*AllGroupOrNode, error)
	GetNowGroupAndName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GroupAndNode, error)
	ChangeNowNode(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*empty.Empty, error)
	AddNode(ctx context.Context, in *NodeMap, opts ...grpc.CallOption) (*empty.Empty, error)
	ModifyNode(ctx context.Context, in *NodeMap, opts ...grpc.CallOption) (*empty.Empty, error)
	DeleteNode(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*empty.Empty, error)
	Latency(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*wrappers.StringValue, error)
}

type nodeClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeClient(cc grpc.ClientConnInterface) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) GetNodes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Nodes, error) {
	out := new(Nodes)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/GetNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetGroup(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*AllGroupOrNode, error) {
	out := new(AllGroupOrNode)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/GetGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetNode(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*AllGroupOrNode, error) {
	out := new(AllGroupOrNode)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/GetNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetNowGroupAndName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GroupAndNode, error) {
	out := new(GroupAndNode)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/GetNowGroupAndName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ChangeNowNode(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/ChangeNowNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) AddNode(ctx context.Context, in *NodeMap, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/AddNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ModifyNode(ctx context.Context, in *NodeMap, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/ModifyNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) DeleteNode(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/DeleteNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Latency(ctx context.Context, in *GroupAndNode, opts ...grpc.CallOption) (*wrappers.StringValue, error) {
	out := new(wrappers.StringValue)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Node/Latency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServer is the server API for Node service.
// All implementations must embed UnimplementedNodeServer
// for forward compatibility
type NodeServer interface {
	GetNodes(context.Context, *empty.Empty) (*Nodes, error)
	GetGroup(context.Context, *empty.Empty) (*AllGroupOrNode, error)
	GetNode(context.Context, *wrappers.StringValue) (*AllGroupOrNode, error)
	GetNowGroupAndName(context.Context, *empty.Empty) (*GroupAndNode, error)
	ChangeNowNode(context.Context, *GroupAndNode) (*empty.Empty, error)
	AddNode(context.Context, *NodeMap) (*empty.Empty, error)
	ModifyNode(context.Context, *NodeMap) (*empty.Empty, error)
	DeleteNode(context.Context, *GroupAndNode) (*empty.Empty, error)
	Latency(context.Context, *GroupAndNode) (*wrappers.StringValue, error)
	mustEmbedUnimplementedNodeServer()
}

// UnimplementedNodeServer must be embedded to have forward compatible implementations.
type UnimplementedNodeServer struct {
}

func (UnimplementedNodeServer) GetNodes(context.Context, *empty.Empty) (*Nodes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodes not implemented")
}
func (UnimplementedNodeServer) GetGroup(context.Context, *empty.Empty) (*AllGroupOrNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroup not implemented")
}
func (UnimplementedNodeServer) GetNode(context.Context, *wrappers.StringValue) (*AllGroupOrNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
}
func (UnimplementedNodeServer) GetNowGroupAndName(context.Context, *empty.Empty) (*GroupAndNode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNowGroupAndName not implemented")
}
func (UnimplementedNodeServer) ChangeNowNode(context.Context, *GroupAndNode) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeNowNode not implemented")
}
func (UnimplementedNodeServer) AddNode(context.Context, *NodeMap) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNode not implemented")
}
func (UnimplementedNodeServer) ModifyNode(context.Context, *NodeMap) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyNode not implemented")
}
func (UnimplementedNodeServer) DeleteNode(context.Context, *GroupAndNode) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (UnimplementedNodeServer) Latency(context.Context, *GroupAndNode) (*wrappers.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Latency not implemented")
}
func (UnimplementedNodeServer) mustEmbedUnimplementedNodeServer() {}

// UnsafeNodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServer will
// result in compilation errors.
type UnsafeNodeServer interface {
	mustEmbedUnimplementedNodeServer()
}

func RegisterNodeServer(s grpc.ServiceRegistrar, srv NodeServer) {
	s.RegisterService(&Node_ServiceDesc, srv)
}

func _Node_GetNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/GetNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetNodes(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/GetGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetGroup(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/GetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetNode(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetNowGroupAndName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetNowGroupAndName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/GetNowGroupAndName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetNowGroupAndName(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ChangeNowNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupAndNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ChangeNowNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/ChangeNowNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ChangeNowNode(ctx, req.(*GroupAndNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_AddNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).AddNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/AddNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).AddNode(ctx, req.(*NodeMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ModifyNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ModifyNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/ModifyNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ModifyNode(ctx, req.(*NodeMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupAndNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/DeleteNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).DeleteNode(ctx, req.(*GroupAndNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Latency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupAndNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Latency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Node/Latency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Latency(ctx, req.(*GroupAndNode))
	}
	return interceptor(ctx, in, info, handler)
}

// Node_ServiceDesc is the grpc.ServiceDesc for Node service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Node_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNodes",
			Handler:    _Node_GetNodes_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _Node_GetGroup_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _Node_GetNode_Handler,
		},
		{
			MethodName: "GetNowGroupAndName",
			Handler:    _Node_GetNowGroupAndName_Handler,
		},
		{
			MethodName: "ChangeNowNode",
			Handler:    _Node_ChangeNowNode_Handler,
		},
		{
			MethodName: "AddNode",
			Handler:    _Node_AddNode_Handler,
		},
		{
			MethodName: "ModifyNode",
			Handler:    _Node_ModifyNode_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _Node_DeleteNode_Handler,
		},
		{
			MethodName: "Latency",
			Handler:    _Node_Latency_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// SubscribeClient is the client API for Subscribe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SubscribeClient interface {
	UpdateSub(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	GetSubLinks(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Links, error)
	AddSubLink(ctx context.Context, in *Link, opts ...grpc.CallOption) (*Links, error)
	DeleteSubLink(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*Links, error)
}

type subscribeClient struct {
	cc grpc.ClientConnInterface
}

func NewSubscribeClient(cc grpc.ClientConnInterface) SubscribeClient {
	return &subscribeClient{cc}
}

func (c *subscribeClient) UpdateSub(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Subscribe/UpdateSub", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscribeClient) GetSubLinks(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Links, error) {
	out := new(Links)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Subscribe/GetSubLinks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscribeClient) AddSubLink(ctx context.Context, in *Link, opts ...grpc.CallOption) (*Links, error) {
	out := new(Links)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Subscribe/AddSubLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscribeClient) DeleteSubLink(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*Links, error) {
	out := new(Links)
	err := c.cc.Invoke(ctx, "/yuhaiin.api.Subscribe/DeleteSubLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubscribeServer is the server API for Subscribe service.
// All implementations must embed UnimplementedSubscribeServer
// for forward compatibility
type SubscribeServer interface {
	UpdateSub(context.Context, *empty.Empty) (*empty.Empty, error)
	GetSubLinks(context.Context, *empty.Empty) (*Links, error)
	AddSubLink(context.Context, *Link) (*Links, error)
	DeleteSubLink(context.Context, *wrappers.StringValue) (*Links, error)
	mustEmbedUnimplementedSubscribeServer()
}

// UnimplementedSubscribeServer must be embedded to have forward compatible implementations.
type UnimplementedSubscribeServer struct {
}

func (UnimplementedSubscribeServer) UpdateSub(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSub not implemented")
}
func (UnimplementedSubscribeServer) GetSubLinks(context.Context, *empty.Empty) (*Links, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubLinks not implemented")
}
func (UnimplementedSubscribeServer) AddSubLink(context.Context, *Link) (*Links, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSubLink not implemented")
}
func (UnimplementedSubscribeServer) DeleteSubLink(context.Context, *wrappers.StringValue) (*Links, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubLink not implemented")
}
func (UnimplementedSubscribeServer) mustEmbedUnimplementedSubscribeServer() {}

// UnsafeSubscribeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubscribeServer will
// result in compilation errors.
type UnsafeSubscribeServer interface {
	mustEmbedUnimplementedSubscribeServer()
}

func RegisterSubscribeServer(s grpc.ServiceRegistrar, srv SubscribeServer) {
	s.RegisterService(&Subscribe_ServiceDesc, srv)
}

func _Subscribe_UpdateSub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServer).UpdateSub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Subscribe/UpdateSub",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServer).UpdateSub(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscribe_GetSubLinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServer).GetSubLinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Subscribe/GetSubLinks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServer).GetSubLinks(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscribe_AddSubLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Link)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServer).AddSubLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Subscribe/AddSubLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServer).AddSubLink(ctx, req.(*Link))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subscribe_DeleteSubLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServer).DeleteSubLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yuhaiin.api.Subscribe/DeleteSubLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServer).DeleteSubLink(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

// Subscribe_ServiceDesc is the grpc.ServiceDesc for Subscribe service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Subscribe_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yuhaiin.api.Subscribe",
	HandlerType: (*SubscribeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateSub",
			Handler:    _Subscribe_UpdateSub_Handler,
		},
		{
			MethodName: "GetSubLinks",
			Handler:    _Subscribe_GetSubLinks_Handler,
		},
		{
			MethodName: "AddSubLink",
			Handler:    _Subscribe_AddSubLink_Handler,
		},
		{
			MethodName: "DeleteSubLink",
			Handler:    _Subscribe_DeleteSubLink_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}
